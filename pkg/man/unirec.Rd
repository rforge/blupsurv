\name{unirec}
\alias{unirec}
\alias{unirec.formula}
\alias{unirec.data.frame}
\alias{print.unirec}
\alias{unirec.object}
\title{ Survival analysis for univariate recurrent event processes 
    with BLUP frailties }
\description{
 Tools for fitting proportional hazards models to clustered
 recurrent events data. Nested frailties are modeled by their
 best linear unbiased predictors under an auxiliary Poisson model.
 The computations are done using the code for \code{\link{bivrec}}, but
 effectively reduce to the method of Ma et al (2001).
}
\usage{\method{unirec}{formula}(formula, data = parent.frame(), ...)}
\arguments{
    \item{formula}{See details}
    \item{data}{See details}
    \item{\dots}{See details}
}
\details{
    Supported parameters are:
    \preformatted{unirec(formula, data = parent.frame(), K1 = 10,
             excludevars1 = NULL, verbose = 1, dispest = "pearson",
             correction = "none", computesd = TRUE, fullS = TRUE, 
             fixzero = NULL, smooth = FALSE, maxiter = 200, 
             convergence = 1e-3, initial = NULL)}
  \describe{
  \item{formula}{a formula object, similar to \code{\link{coxph}}. The response to the
      left of the \code{~} should be a survival object generated by \code{\link{Surv}}, with
      three components (start, stop, status). The
      right side must contain an \code{id(x)} term, where \code{x} is a variable that takes a
      unique value for each subject within a cluster. It may also contain a \code{cluster(y)} 
      term if \code{y} is the variable that indicates cluster membership, and a \code{strata(z)}
      term.
  }
  \item{data}{a \code{data.frame} with columns corresponding to the terms 
      in the formula.}
  \item{K1}{either an integer, a vector of integers, or a value between 0 and 1,
    to determine the level of discretization. If it is an integer, \code{K1} gives the
    number of breakpoints in the baseline hazard for the process. 
    If it is a vector of integers, \code{K1} should have length equal to the 
    number of strata, and each value gives the number of breakpoints in the 
    baseline hazard for each stratum. If it is a number between 0 and 1, it gives
    the ratio of the number of breakpoints relative to the maximum possible. 
    Defaults to 10.}
  \item{excludevars1}{ a vector of strings giving the names of variables or 
    interactions that should be excluded from the model. }
  \item{verbose}{ an integer from 0 to 3 that determines the quantity of output
        printed to the screen. Setting \code{verbose=0} is completely silent.}
  \item{dispest}{ a string, determining the method used to estimate the dispersion
    parameters. Possible values are \code{"pearson", "marginal", "ohlsson"}, defaults
    to \code{"pearson"}. }
  \item{correction}{ a string describing the degree-of-freedom correction proposed
    by Ma. It only applies when \code{dispest="pearson"}. 
    Possible values are \code{"single", "double", "none"}, defaults to \code{"none"} }
  \item{computesd}{ a boolean determining whether standard errors should be computed. 
    Defaults to \code{TRUE}. }
  \item{fullS}{ logical determining whether to use the full sensitivity matrix
    in computing standard errors, or only the covariate portion. Using \code{fullS=TRUE}
    leads to more accurate results but increases computer time. Defaults to \code{TRUE}. }
  \item{fixzero}{ a vector of strings, listing any dispersion parameters that should
    be set to 0. Can contain any subset of \code{"clust1", "subj1"},
    all else is ignored. Defaults to \code{NULL}. }
  \item{smooth}{ logical, determines whether the baseline hazard should be smoothed
    at each iteration. Defaults to \code{FALSE}. }
  \item{maxiter}{ an integer giving the maximum number of iterations permitted. }
  \item{convergence}{ double, determines the value of the convergence criterion 
    required at termination. }
  \item{initial}{ a list of initial values in the format used by the code internally. }
  }
}
\value{
     An object of class \code{unirec} with the following components:
     \item{call}{the original call to the model-fitting function}
     \item{regression}{a list containing results from the regression fit in the last
        iteration. It has components
        \describe{
            \item{\code{coefficients}}{a vector of regression coefficients for the
                process}
            \item{\code{loglik}}{conditional loglikelihood.}
        }
     }
     \item{frailty}{a list containing results from the frailty estimation in the last
        iteration. It has components
        \describe{
            \item{\code{clust}}{cluster-level frailty estimates}
            \item{\code{subj}}{subject-level frailty estimates}
        }
     }
     \item{dispersion}{a list containing results from the dispersion parameter
         estimation in the last iteration. It has components
        \describe{
            \item{\code{clust}}{cluster-level frailty variance}
            \item{\code{subj}}{subject-level frailty variance}  
        }
     }
     \item{hazard}{a list describing the baseline hazard. It has components
        \describe{
            \item{\code{breaks}}{matrix of breakpoints in the hazard for 
                each stratum}
            \item{\code{hazard}}{matrix of hazards in each interval for
                each stratum}
        }
     }
     \item{summaries}{a list of summary matrices. It has components
        \describe{
            \item{\code{regression}}{summary for the regression coefficients}
            \item{\code{dispersion}}{summary for the dispersion parameters}
        }
     }

}
\references{R. Ma. \dQuote{Random effects Cox models: A Poisson modelling approach},
\emph{Biometrika}, 90 (1) 157-169, 2001.

E. Sharef and R. Strawderman. \dQuote{A nested frailty model for
clustered bivariate recurrent events}, \emph{in preparation}.
}
\author{Emmanuel Sharef \email{ess28@cornell.edu} }
\seealso{\code{\link{summary.unirec}}, \code{\link{plot.unirec}}, \code{\link{bivrec}}}
\examples{
    data(m10Ji5)
    
    fit <- unirec( Surv(start, stop, delta) ~ 
                Z1 + cluster(i) + id(j), data = m10Ji5 )
                
    summary(fit)
    plot(fit)
}
\keyword{ survival }
